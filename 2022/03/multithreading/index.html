<!DOCTYPE html>
<html lang="en" >

  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">


<meta property="og:title" content="Multithreading" />
<meta property="og:description" content="记录 JavaSE 中多线程的一些基本的概念和方法使用" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://junq0420.github.io/2022/03/multithreading/" />
<meta property="article:published_time" content="2022-03-19T13:55:40+08:00" />
<meta property="article:modified_time" content="2022-03-19T13:55:40+08:00" />



<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Multithreading"/>
<meta name="twitter:description" content="记录 JavaSE 中多线程的一些基本的概念和方法使用"/>
<meta name="generator" content="Hugo 0.84.0" />


    
<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BlogPosting",
  "headline": "Multithreading",
  "url": "https://junq0420.github.io/2022/03/multithreading/",
  "wordCount": "1308",
  "datePublished": "2022-03-19T13:55:40+08:00",
  "dateModified": "2022-03-19T13:55:40+08:00",
  "author": {
    "@type": "Person",
    "name": "Jun qiang"
  },
  "keywords": "Java, Java_Advance"
}
</script>



    <link rel="canonical" href="https://junq0420.github.io/2022/03/multithreading/">

    <title>Multithreading | My Blog</title>

    
    <!-- combined, minified CSS -->
    
    <link href="https://junq0420.github.io/css/style.5661e2c97fcfc5e47dc9df16e3ca8a3598b1d2f4acbec96eec49c72a9d6e7a31.css" rel="stylesheet" integrity="sha256-VmHiyX/PxeR9yd8W48qKNZix0vSsvslu7EnHKp1uejE=" crossorigin="anonymous">
    

    <!-- minified Font Awesome for SVG icons -->
    
    <script defer src="https://junq0420.github.io/js/fontawesome.min.f5072c55a0721857184db93a50561d7dc13975b4de2e19db7f81eb5f3fa57270.js" integrity="sha256-9QcsVaByGFcYTbk6UFYdfcE5dbTeLhnbf4HrXz&#43;lcnA=" crossorigin="anonymous"></script>

    <!-- RSS 2.0 feed -->
    

    

  </head>

  <body>

    
    <div class="blog-masthead">
      <div class="container">
        <nav class="nav blog-nav">
          <a class="nav-link " href="https://junq0420.github.io">Home</a>
          
          <a class="nav-link" href="/archives/" title="">Archives</a>
          
          
          <a class="nav-link" href="/categories/" title="">Categories</a>
          
          
          <a class="nav-link" href="/tags/" title="">Tags</a>
          
        </nav>
      </div>
    </div>
    

    
    
    <header class="blog-header">
      <div class="container">
        <h1 class="blog-title" dir="auto"><a href="https://junq0420.github.io" rel="home">My Blog</a></h1>
        <p class="lead blog-description" dir="auto"><ul>
<li>保持兴趣，持续学习 :)</li>
</ul>
</p>
      </div>
    </header>
    
    

    
    <div class="container">
      <div class="row">
        <div class="col-sm-8 blog-main">

          


<article class="blog-post">
  <header>
    <h2 class="blog-post-title" dir="auto"><a href="https://junq0420.github.io/2022/03/multithreading/">Multithreading</a></h2>
    <p class="blog-post-meta">
<time datetime="2022-03-19T13:55:40+08:00">2022-03-19</time>
 in 
<span class="fas fa-folder" aria-hidden="true"></span>&nbsp;<a href="/categories/java/" rel="category tag">Java</a>


<span class="fas fa-tag" aria-hidden="true"></span>&nbsp;<a href="/tags/java_advance/" rel="tag">Java_Advance</a>

</p>
  </header>
  <p>记录 JavaSE 中多线程的一些基本的概念和方法使用</p>

<blockquote>
<p><strong>学习笔记，仅供参考</strong></p>

<p><strong>参考</strong>：<a href="https://www.yuque.com/books/share/ddbdba56-dc9f-4997-9e18-d9e69309d343/wgctzt">B站Mirco_Frank - java 进阶</a> | <a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/index.html">官网教程</a> | <a href="https://www.javatpoint.com/multithreading-in-java">javatpoint</a></p>
</blockquote>

<hr />

<h2 id="目录">目录</h2>

<ul>
<li><p><a href="#相关概念">相关概念</a></p></li>

<li><p><a href="#创建线程">创建线程</a></p>

<ul>
<li><p><a href="#继承Thread类">继承 Thread 类</a></p></li>

<li><p><a href="#实现Runnable接口">实现 Runnable 接口</a></p></li>
</ul></li>

<li><p><a href="#多线程抢鞋">多线程抢鞋</a></p>

<ul>
<li><a href="#守护线程">守护线程</a></li>
</ul></li>

<li><p><a href="#线程同步">线程同步</a></p>

<ul>
<li><p><a href="#锁对象">锁对象</a></p></li>

<li><p><a href="#同步方法">同步方法</a></p></li>

<li><p><a href="#同步锁">同步锁</a></p></li>
</ul></li>

<li><p><a href="#Thread类">Thread 类</a></p></li>

<li><p><a href="#线程状态">线程状态</a></p></li>

<li><p><a href="#wait和notify">wait 和 notify</a></p></li>
</ul>

<hr />

<h2 id="a-name-相关概念-a-相关概念"><a name="相关概念">📖</a> 相关概念</h2>

<ul>
<li><p><strong>单核</strong> ： 当计算机只有一个核时，表面上它好像同时在运行多个程序，其实每个时刻它仅执行一个程序，其他的程序处于挂起（暂停），由于 CPU 的运算速度快，程序之间的转换快，导致看起来好像是同时进行的（一个人干多样活）</p></li>

<li><p><strong>多核</strong> ： 现在的计算机都是多核的，每个核执行一个程序，不用再来回切换，从而提高了效率（多个人干多样活）</p></li>

<li><p><strong>并发</strong> ： 单个 CPU 执行多个线程，相互争抢资源，来回切换（没钱，用多线程并发来提高效率）</p></li>

<li><p><strong>并行</strong> ： 多个 CPU 同时执行不同的线程，互补争抢 CPU 资源（有钱）</p></li>

<li><p><strong>进程</strong> ： 通常有一套完整、独有的基本运行时资源，而且它们有自己的内存空间</p></li>

<li><p><strong>线程</strong> ： 创建线程要比创建进程更省资源，线程寄生于进程，一个进程至少有一个线程，这些 <strong>线程共享进程的资源</strong> ，从而保证了高效但也存在隐患</p></li>

<li><p><strong>主线程（main thread）</strong> ： 通常指 main 方法，它有能力创建其他的线程</p></li>

<li><p><strong>多线程</strong> ： 一个进程的多个线程同时对该进程的某个共享变量进行操作</p></li>
</ul>

<p><img src="https://cdn.jsdelivr.net/gh/junq0420/blog_image/Multithreading_relation.jpg" alt="进程线程关系图" /></p>

<hr />

<h2 id="a-name-创建线程-a-创建线程"><a name="创建线程">🧵</a> 创建线程</h2>

<p>创建线程有两种方式：继承 Thread 类 和 实现 Runnable 接口，先看继承 Thread 类</p>

<h3 id="a-name-继承thread类-a-继承-thread-类"><a name="继承Thread类"></a>继承 Thread 类</h3>

<p>先写继承类, 然后再 Test 类的 main 方法中来实例它，为了展现各线程来回抢占进程（程序）资源，用 while (true) 死循环</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e"> *  继承 Thread 类
</span><span style="color:#75715e"> *  重写父类的 run() 方法 
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyThread</span> <span style="color:#66d9ef">extends</span> Thread <span style="color:#f92672">{</span>
    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;my thread running...&#34;</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

<span style="color:#75715e">/*************************分隔线****************************/</span>

<span style="color:#75715e">/**
</span><span style="color:#75715e"> *  测试类
</span><span style="color:#75715e"> *  将上面继承 Thread 的类实例化
</span><span style="color:#75715e"> */</span>

<span style="color:#66d9ef">public</span> calss Test <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        MyThread myThread <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyThread<span style="color:#f92672">();</span>
        <span style="color:#75715e">// 调用 start 方法，启动线程，让其变为 Runnable（可运行状态）
</span><span style="color:#75715e"></span>        myThread<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>

        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;main thread running...&#34;</span><span style="color:#f92672">)</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span></code></pre></div>
<p>结果图如下：</p>

<p><img src="https://cdn.jsdelivr.net/gh/junq0420/blog_image/ExtendThread.jpg" alt="继承Thread类" /></p>

<h3 id="a-name-实现runnable接口-a-实现-runnable-接口"><a name="实现Runnable接口"></a>实现 Runnable 接口</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e"> *  实现 Runnable 接口
</span><span style="color:#75715e"> *  重写父类的 run() 方法 
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyThread</span> <span style="color:#66d9ef">implements</span> Runnable <span style="color:#f92672">{</span>
    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;my thread running...&#34;</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

<span style="color:#75715e">/*************************分隔线****************************/</span>

<span style="color:#75715e">/**
</span><span style="color:#75715e"> *  测试类
</span><span style="color:#75715e"> *  将上面实现 Runnable 接口的类实例化
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> calss Test <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        MyThread myThread <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyThread<span style="color:#f92672">();</span>
        <span style="color:#75715e">// 因为实现 Runnable 接口类的实例对象无法调用 start() 方法，所以要将它交给 Thread 类的实例对象
</span><span style="color:#75715e"></span>        Thread thread <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(</span>myThread<span style="color:#f92672">);</span>
        <span style="color:#75715e">// 调用 start 方法，启动线程，让其变为 Runnable（可运行状态）
</span><span style="color:#75715e"></span>        thread<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>

        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;main thread running...&#34;</span><span style="color:#f92672">)</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span></code></pre></div>
<p>上面代码为了演示所以写的比较多余，因为实例出的对象没啥操作，所以可以进行 <strong>简化</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// extends Thread class
</span><span style="color:#75715e"></span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> myThread<span style="color:#f92672">()).</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>

<span style="color:#75715e">// implements Runnable interface
</span><span style="color:#75715e"></span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> myThread<span style="color:#f92672">())).</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>

<span style="color:#75715e">// implements Runnable by use lambda expression
</span><span style="color:#75715e">// 用 λ 表达式简化匿名内部类，从而省去中间的实现类
</span><span style="color:#75715e"></span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(</span> <span style="color:#f92672">()</span> <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">){</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;my thread running...&#34;</span><span style="color:#f92672">)</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span> <span style="color:#f92672">)).</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span></code></pre></div>
<p>从上面两种创建方式可知：</p>

<p><strong style="color: red">相同点</strong> : 两种方式都要重写 run() 方法才行，启动线程时，也都是要调用 start() 方法</p>

<p><strong style="color: orange">不同点</strong> : 继承类的实例对象直接调用 start()，而实现类的实例对象要交给 Thread 对象才能调用 start()</p>

<p><img src="https://cdn.jsdelivr.net/gh/junq0420/blog_image/running_map.jpg" alt="执行图" /></p>

<blockquote style="background-color: #689; font-style: italic; color: black; border-left: 2px solid red">【问题】线程为什么不直接调用 run() 方法，而是调用的 start() 方法？

【解答】由于多线程的执行是各不影响的，所以每个线程都会有一个独立的栈。而若在 main 中直接调用 run() 方法，那么所进的栈就是主线程当前的栈，这样就会影响到主线程的执行，就不是多线程了。通过调用 start() 则是分配到独立的堆栈，在新的栈中调用 run() 执行程序，即开启了新的线程
</blockquote>

<p>当创建线程时，还可以设置线程的名字</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// 在 Thread 的有参构造器设置线程名
</span><span style="color:#75715e"></span><span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(</span>myThread<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;mythread&#34;</span><span style="color:#f92672">);</span>

<span style="color:#75715e">// 获取当前线程名
</span><span style="color:#75715e"></span>String threadName <span style="color:#f92672">=</span> Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">().</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">();</span></code></pre></div>
<hr />

<h2 id="a-name-多线程抢鞋-a-多线程抢鞋"><a name="多线程抢鞋">👟</a> 多线程抢鞋</h2>

<p>在如今互联网发达的时代，多线程的使用就在我们日常生活中。比如：双十一的淘宝抢购、火车站买票等，就连公共厕所的占用也可以用多线程解释。它主要的特点就是多个线程对共享资源的抢占，下面就以抢鞋为例。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e"> *  实现 Runnable 类
</span><span style="color:#75715e"> *  定义鞋的数量以及鞋被抢后打印信息
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ShoesThread</span> <span style="color:#66d9ef">implements</span> Runnale <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> shoes <span style="color:#f92672">=</span> 10<span style="color:#f92672">;</span>  <span style="color:#75715e">// 假定有十双鞋
</span><span style="color:#75715e"></span>
    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>shoes <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// 显示谁抢到第几双鞋
</span><span style="color:#75715e"></span>            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">().</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">()</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;抢到第&#34;</span> <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>shoes<span style="color:#f92672">--)</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;双鞋!!!&#34;</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

<span style="color:#75715e">/**************************分隔线***************************/</span>

<span style="color:#75715e">/**
</span><span style="color:#75715e"> *  模拟三个用户抢鞋
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> calss Test <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// 实例化 ShoesThread
</span><span style="color:#75715e"></span>        ShoesThread shoesThread <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ShoesThread<span style="color:#f92672">();</span>
        <span style="color:#75715e">// 创建并开启三个用户线程
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(</span>shoesThread<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;Tom&#34;</span><span style="color:#f92672">).</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
        <span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(</span>shoesThread<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;Jerry&#34;</span><span style="color:#f92672">).</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
        <span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(</span>shoesThread<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;Frank&#34;</span><span style="color:#f92672">).</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span></code></pre></div>
<p>运行结果图如下：</p>

<p><img src="https://cdn.jsdelivr.net/gh/junq0420/blog_image/LootShoes.jpg" alt="抢鞋" width="70%"></p>

<p>当然，用继承 Thread 类也能实现这种抢夺公共资源的情形，只需将 <code>implements Runnable</code> 改为 <code>extends Thread</code> 即可</p>

<p>注意与下面的例子区别开来</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// 这样写就是三家鞋店，一人抢一家，各抢十双
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 这样就不是三个线程抢占共享资源了
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> ShoesThread<span style="color:#f92672">(),</span> <span style="color:#e6db74">&#34;Tom&#34;</span><span style="color:#f92672">).</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
    <span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> ShoesThread<span style="color:#f92672">(),</span> <span style="color:#e6db74">&#34;Jerry&#34;</span><span style="color:#f92672">).</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
    <span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> ShoesThread<span style="color:#f92672">(),</span> <span style="color:#e6db74">&#34;Frank&#34;</span><span style="color:#f92672">).</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
    
<span style="color:#f92672">}</span></code></pre></div>
<p><strong style="color: #2ff; font-size: 120%;">注意</strong></p>

<p>继承 Thread 类与实现 Runnable 接口在用法上没啥区别，但由于 Java 只支持单继承，所以继承 Thread 类的方式就会有大大局限，不能再继承其他的类；而实现 Runnable 接口的类则还有一个继承其他类的机会，让其更加的灵活。所以一般更多的是使用实现 Runnable 接口的方式来创建线程</p>

<h3 id="a-name-守护线程-a-守护线程"><a name="守护线程"></a>守护线程</h3>

<p>有前台抢鞋的线程，那就会有后台管理更新数据的线程，即 <strong>守护线程</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// 1. 实现 Runnable 接口创建一个线程
</span><span style="color:#75715e"></span>Thread daemonThread <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(</span> <span style="color:#f92672">()</span> <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">{</span>
    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;daemon thread is running...&#34;</span><span style="color:#f92672">);</span>
<span style="color:#f92672">}</span> <span style="color:#f92672">);</span>

<span style="color:#75715e">// 2. 将创建的线程设置为守护线程
</span><span style="color:#75715e"></span>daemonThread<span style="color:#f92672">.</span><span style="color:#a6e22e">setDaemon</span><span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">);</span>

<span style="color:#75715e">// 3. 开启守护线程
</span><span style="color:#75715e"></span>daemonThread<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>

<span style="color:#75715e">// ！注意：守护线程要写在其他线程的前面
</span></code></pre></div>
<p><img src="https://cdn.jsdelivr.net/gh/junq0420/blog_image/daemonThread.jpg" alt="daemon-thread" /></p>

<hr />

<h2 id="a-name-线程同步-a-线程同步"><a name="线程同步">🔒</a> 线程同步</h2>

<p>为了让抢鞋的情形更加贴近现实，不让鞋一瞬间就被抢完，每被抢一双就延时一段时间。通过 <code>Thread.sleep()</code> 方法来让当前的线程睡眠一段时间，以此达到延时的效果</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e"> *  使用 sleep() 方法延时抢鞋
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ShoesThread</span> <span style="color:#66d9ef">implements</span> Runnale <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> shoes <span style="color:#f92672">=</span> 10<span style="color:#f92672">;</span>  <span style="color:#75715e">// 假定有十双鞋
</span><span style="color:#75715e"></span>
    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>shoes <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// 使用 sleep() 时，要捕获 InterruptedException
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 当该线程运行中被中断时抛出
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
                Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">sleep</span><span style="color:#f92672">(</span>500<span style="color:#f92672">);</span>  <span style="color:#75715e">// 线程睡眠0.5秒
</span><span style="color:#75715e"></span>            <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>InterruptedException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>

            <span style="color:#75715e">// 显示谁抢到第几双鞋
</span><span style="color:#75715e"></span>            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">().</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">()</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;抢到第&#34;</span> <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>shoes<span style="color:#f92672">--)</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;双鞋!!!&#34;</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span></code></pre></div>
<p>但是，加上延时后程序的运行就出现问题</p>

<p><img src="https://cdn.jsdelivr.net/gh/junq0420/blog_image/no_safe.jpg" alt="线程不安全" /></p>

<p>这就表明线程是 <strong>非安全、不同步</strong> 的，下面就介绍三种方法使得线程同步</p>

<h3 id="a-name-锁对象-a-锁对象"><a name="锁对象"></a>锁对象</h3>

<p>先创建一个 Object 类的对象 lock，然后交给 <code>synchronized(lock) {...}</code> （花括号叫同步代码块），让同步代码块包住 while 的内容即可</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e"> *  锁对象同步
</span><span style="color:#75715e"> *  可能由于 CPU 的运算速度太快，导致只有一个线程在执行
</span><span style="color:#75715e"> *  所以将鞋数改为 50，while 改为死循环，用 if 语句做判断
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> shoes <span style="color:#f92672">=</span> 50<span style="color:#f92672">;</span>
Object lock <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Object<span style="color:#f92672">();</span>

<span style="color:#a6e22e">@Override</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">synchronized</span><span style="color:#f92672">(</span>lock<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>shoes <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
                    Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">sleep</span><span style="color:#f92672">(</span>500<span style="color:#f92672">);</span>
                <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>InterruptedException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
                <span style="color:#f92672">}</span>

                System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">().</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">()</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;抢到第&#34;</span> <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>shoes<span style="color:#f92672">--)</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;双鞋!!!&#34;</span><span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span></code></pre></div>
<p>经过几次运行，得到了三个线程同步共享变量的情况</p>

<p><img src="https://cdn.jsdelivr.net/gh/junq0420/blog_image/synchronized.jpg" alt="线程同步" /></p>

<h3 id="a-name-同步方法-a-同步方法"><a name="同步方法"></a>同步方法</h3>

<p>与锁对象类似，只不过不用新建 Object 对象，将同步代码块的内容直接拿出去作为一个方法来直接调用。与锁对象相比，则 <strong>更推荐同步方法</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> shoes <span style="color:#f92672">=</span> 50<span style="color:#f92672">;</span>

<span style="color:#a6e22e">@Override</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        shoesCatch<span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

<span style="color:#75715e">/**********************分隔线**************************/</span>
<span style="color:#75715e">/**
</span><span style="color:#75715e"> *  同步方法
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">synchronized</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">shoesCatch</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>shoes <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
            Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">sleep</span><span style="color:#f92672">(</span>500<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>InterruptedException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
        <span style="color:#f92672">}</span>

        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">().</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">()</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;抢到第&#34;</span> <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>shoes<span style="color:#f92672">--)</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;双鞋!!!&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span></code></pre></div>
<h3 id="a-name-同步锁-a-同步锁"><a name="同步锁"></a>同步锁</h3>

<p>除了锁对象和同步方法外，还有使用同步锁的方法来达到线程同步，它需要先提前 new Lock 类的对象，然后使用它的 <code>lock()</code> 和 <code>unlock()</code> 方法包住要同步的内容</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e"> *  同步锁
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> shoes <span style="color:#f92672">=</span> 50<span style="color:#f92672">;</span>
Lock reentrantLock <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ReentrantLock<span style="color:#f92672">();</span>  <span style="color:#75715e">// 新建同步锁对象
</span><span style="color:#75715e"></span>

<span style="color:#a6e22e">@Override</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// 上锁
</span><span style="color:#75715e"></span>        reentrantLock<span style="color:#f92672">.</span><span style="color:#a6e22e">lock</span><span style="color:#f92672">();</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>shoes <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
                Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">sleep</span><span style="color:#f92672">(</span>500<span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>InterruptedException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
            <span style="color:#f92672">}</span>

            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">().</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">()</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;抢到第&#34;</span> <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>shoes<span style="color:#f92672">--)</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;双鞋!!!&#34;</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
        <span style="color:#75715e">// 解锁
</span><span style="color:#75715e"></span>        reentrantLock<span style="color:#f92672">.</span><span style="color:#a6e22e">unlock</span><span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span></code></pre></div>
<p><strong style="color: #f5f; font-size: 120%;">区别</strong></p>

<ul>
<li><p>synchronized 是关键字；Lock 是接口</p></li>

<li><p>synchronized 自动获取锁和释放锁；Lock 则需要手动的去获取锁和释放锁</p></li>

<li><p>synchronized 无法判断锁的状态；Lock 则能判断锁的状态</p></li>

<li><p>synchronized 同步时，若一个线程阻塞，其他线程就会一直等待；Lock 同步时，一个线程阻塞，其他线程可以中断等待而做其他的事</p></li>

<li><p>synchronized 适合少量代码的同步；Lock 则适合大量代码的同步</p></li>
</ul>

<p>更多的区别参考：</p>

<p><a href="https://juejin.cn/post/7072286719566938148">Lock与synchronized的区别？</a> | <a href="https://juejin.cn/post/6844903984033972237">Java同步锁-synchronized与lock</a> | <a href="https://juejin.cn/post/7011857300562542599">JUC并发编程—Synchronized锁和 Lock 锁</a></p>

<hr />

<h2 id="a-name-thread类-a-thread-类"><a name="Thread类">🎤</a> Thread 类</h2>

<p>下面仅列举学习时所用或所能理解的方法，更详尽的参考<a href="https://docs.oracle.com/javase/9/docs/api/index.html?overview-summary.html">API DOC</a></p>

<h3 id="字段">字段</h3>

<ul>
<li><p><strong><em><code>MAX_PRIORITY</code></em></strong> &emsp; // 线程能达到的最大优先级</p></li>

<li><p><strong><em><code>MIN_PRIORITY</code></em></strong> &emsp; // 线程的最小优先级</p></li>

<li><p><strong><em><code>NORM_PRIORITY</code></em></strong> &emsp; // 线程默认的优先级</p></li>
</ul>

<p><strong>线程调度</strong> ： 每个线程的优先级都是由系统随机分配的，但也可以通过 <code>setPriority()</code> 方法来设置线程的优先级别。线程的优先级范围为 1 - 10，一般主线程 main 的优先级为 5。在 WIN10 上通过代码验证，大体上看优先级高的会先执行，但可能由于 CPU 处理太快或者操作系统对优先级的支持不同，还是不太理想，有交叉执行的情况</p>

<h3 id="构造器">构造器</h3>

<ul>
<li><p><strong><em><code>Thread()</code></em></strong> &emsp; // 无参构造器，生成一个线程对象</p></li>

<li><p><strong><em><code>Thread(Runnable target)</code></em></strong> &emsp; // 接收 Runnable 的实现类对象</p></li>

<li><p><strong><em><code>Thread(Runnable target, String name)</code></em></strong> &emsp; // 接收 Runnable 的实现类对象，并设置该线程的名字</p></li>
</ul>

<h3 id="静态方法">静态方法</h3>

<ul>
<li><p><strong><em><code>currentThread()</code></em></strong> &emsp; // 返回当前执行线程对象</p></li>

<li><p><strong><em><code>interrupted()</code></em></strong> &emsp; // 判断当前线程是否中断，中断返回 true；否则 false</p></li>

<li><p><strong><em><code>sleep​(long millis)</code></em></strong> &emsp; // 让当前的线程睡 millis 毫秒</p></li>

<li><p><strong><em><code>yield()</code></em></strong> &emsp; // 线程让步，向调度程序提示当前线程愿意放弃其当前对 CPU 的使用</p></li>
</ul>

<h3 id="实例方法">实例方法</h3>

<ul>
<li><p><strong><em><code>start()</code></em></strong> &emsp; // 开启线程</p></li>

<li><p><strong><em><code>getId() | getName() | getPriority()</code></em></strong> &emsp; // 获取该线程的 id | 线程名 | 优先级别</p></li>

<li><p><strong><em><code>setDaemon(boolean on) | setName(String name) | setPriority(int newPriority)</code></em></strong> &emsp; // 设置该线程为守护线程 | 线程名 | 优先级别</p></li>

<li><p><strong><em><code>interrupt()</code></em></strong> &emsp; // 中断该线程，中断机制参考<a href="https://zhuanlan.zhihu.com/p/149205707#:~:text=%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD%E5%8D%B3%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%A2%AB%E5%85%B6%E4%BB%96%E7%BA%BF%E7%A8%8B%E7%BB%99%E6%89%93%E6%96%AD%E4%BA%86%EF%BC%8C%E5%AE%83%E4%B8%8E%20stop,%E6%9C%80%E5%A4%A7%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%EF%BC%9Astop%20%E6%98%AF%E7%94%B1%E7%B3%BB%E7%BB%9F%E5%BC%BA%E5%88%B6%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B%EF%BC%8C%E8%80%8C%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD%E5%88%99%E6%98%AF%E7%BB%99%E7%9B%AE%E6%A0%87%E7%BA%BF%E7%A8%8B%E5%8F%91%E9%80%81%E4%B8%80%E4%B8%AA%E4%B8%AD%E6%96%AD%E4%BF%A1%E5%8F%B7%EF%BC%8C%E5%A6%82%E6%9E%9C%E7%9B%AE%E6%A0%87%E7%BA%BF%E7%A8%8B%E6%B2%A1%E6%9C%89%E6%8E%A5%E6%94%B6%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%B9%B6%E7%BB%93%E6%9D%9F%E7%BA%BF%E7%A8%8B%EF%BC%8C%E7%BA%BF%E7%A8%8B%E5%88%99%E4%B8%8D%E4%BC%9A%E7%BB%88%E6%AD%A2%EF%BC%8C%E5%85%B7%E4%BD%93%E6%98%AF%E5%90%A6%E9%80%80%E5%87%BA%E6%88%96%E8%80%85%E6%89%A7%E8%A1%8C%E5%85%B6%E4%BB%96%E9%80%BB%E8%BE%91%E7%94%B1%E7%9B%AE%E6%A0%87%E7%BA%BF%E7%A8%8B%E5%86%B3%E5%AE%9A%E3%80%82">这里</a>、<a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/interrupt.html">官网教程</a></p></li>

<li><p><strong><em><code>isAlive()</code></em></strong> &emsp; // 判断该线程是否还存活</p></li>

<li><p><strong><em><code>isDaemon()</code></em></strong> &emsp; // 判断该线程是否为守护线程</p></li>

<li><p><strong><em><code>isInterrupted()</code></em></strong> &emsp; // 判断该线程是否被中断</p></li>

<li><p><strong><em><code>join()</code></em></strong> &emsp; // 线程插队，被插的线程要等该线程执行完才能继续；重载可以设置等待多少毫秒</p></li>
</ul>

<hr />

<h2 id="a-name-线程状态-a-线程状态-生命周期"><a name="线程状态">⏳</a> 线程状态(生命周期)</h2>

<p>线程通常有六种状态，如下所示。可以查看 API 中的 <code>java.lang.Thread.State</code></p>

<ul>
<li><p><strong><em><code>New</code></em></strong> &emsp; // 新建状态，使用 new 关键字创建了线程，但还没开启</p></li>

<li><p><strong><em><code>Runnable</code></em></strong> &emsp; // 可运行状态，调用 start() 后，线程开始在 JVM 中执行；线程调度提供固定的时间切片给每个线程去运行（即 Running），当时间切片结束后，放弃 CPU 资源给其他线程，等待下一轮时间切片</p></li>

<li><p><strong><em><code>Block</code></em></strong> &emsp; // 阻塞状态，线程被阻塞，等待监视器锁</p></li>

<li><p><strong><em><code>Waiting</code></em></strong> &emsp; // 等待状态，线程等待另外的线程执行特别的行为</p></li>

<li><p><strong><em><code>Timed Waiting</code></em></strong> &emsp; // 计时等待状态，线程等待另外的线程执行一个动作，直到指定的时间结束为止，防止线程死等</p></li>

<li><p><strong><em><code>Terminated</code></em></strong> &emsp; // 终止状态，线程正常完成所给任务或以意外事件而终止，如 segmentation fault or unhandle exception</p></li>
</ul>

<p><img src="https://cdn.jsdelivr.net/gh/junq0420/blog_image/ThreadState.jpg" alt="ThreadState" /></p>

<p>可以通过联想斗地主的场景来大致理解这些线程状态，三人进入房间准备就绪（创建了三个线程），都准备好了开始游戏（三个线程开启），抢地主谁抢到谁先出牌（三个线程阻塞，抢同步锁，谁抢到谁执行），地主出牌时👲农民👨‍🌾都在等着不能打牌（抢到锁的开始执行，其他线程等待），要是在规定的出牌时间未出牌就会轮到下家（另外两个线程计时等待，等地主出完牌或时间到），于是三人开始了愉快的打牌（三个线程一直在阻塞抢锁、执行、等待），等某人打完牌结束游戏（三个线程终止）</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MultithreadingTest</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// 声明两个线程，声明为 static 方便重写 run() 时好直接用
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> Thread thread1<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> Thread thread2<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">/**
</span><span style="color:#75715e">         *  新建 thread1
</span><span style="color:#75715e">         */</span> 
        thread1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(()</span> <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// 先让线程1打印 50 次
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> 50<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
               System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">().</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">()</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; is running...&#34;</span><span style="color:#f92672">);</span>
               <span style="color:#75715e">// 在打印第四次时让线程2插队
</span><span style="color:#75715e"></span>               <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>i <span style="color:#f92672">==</span> 3<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                   <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
                       thread2<span style="color:#f92672">.</span><span style="color:#a6e22e">join</span><span style="color:#f92672">();</span>
                   <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>InterruptedException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                       e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
                   <span style="color:#f92672">}</span>
               <span style="color:#f92672">}</span>
            <span style="color:#f92672">}</span>
            
            <span style="color:#75715e">// 让线程1睡会
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
                Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">sleep</span><span style="color:#f92672">(</span>500<span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>InterruptedException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">},</span> <span style="color:#e6db74">&#34;thread1&#34;</span><span style="color:#f92672">);</span>

        <span style="color:#75715e">/**
</span><span style="color:#75715e">         *  新建 thread2
</span><span style="color:#75715e">         */</span>
        thread2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(</span> <span style="color:#f92672">()</span> <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// 让线程2打印10，并且每次都看下线程1在被插队后的状态
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> 10<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
                System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">().</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">()</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; is running...&#34;</span><span style="color:#f92672">);</span>
                System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;State of thread1 : &#34;</span> <span style="color:#f92672">+</span> thread1<span style="color:#f92672">.</span><span style="color:#a6e22e">getState</span><span style="color:#f92672">());</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span> <span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;thread2&#34;</span><span style="color:#f92672">);</span>

        <span style="color:#75715e">// 查看新建线程1后的状态
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;State of thread1 : &#34;</span> <span style="color:#f92672">+</span> thread1<span style="color:#f92672">.</span><span style="color:#a6e22e">getState</span><span style="color:#f92672">());</span>
        thread1<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>  <span style="color:#75715e">// 开启两个线程
</span><span style="color:#75715e"></span>        thread2<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
        <span style="color:#75715e">// 查看开启线程1后的状态
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;State of thread1 : &#34;</span> <span style="color:#f92672">+</span> thread1<span style="color:#f92672">.</span><span style="color:#a6e22e">getState</span><span style="color:#f92672">());</span>

        <span style="color:#75715e">// 让主线程一直追踪线程1状态，给短暂的间隔防止主线程过多抢占
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;State of thread1 : &#34;</span> <span style="color:#f92672">+</span> thread1<span style="color:#f92672">.</span><span style="color:#a6e22e">getState</span><span style="color:#f92672">());</span>
            <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
                Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">sleep</span><span style="color:#f92672">(</span>1<span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>InterruptedException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span></code></pre></div>
<p>程序可能还不完善，但好在有时能较好地显示出线程1的六个状态，如下图所示</p>

<p><img src="https://cdn.jsdelivr.net/gh/junq0420/blog_image/ThreadStates.jpg" alt="ThreadStates" /></p>

<h2 id="a-name-wait和notify-a-wait-和-notify"><a name="wait和notify">🚧</a> wait 和 notify</h2>

<p>wait() 和 notify() 方法是继承自 Object 类，当线程中某对象调用 wait() 时，该线程暂时停止执行，一直等待，直到其他的线程在同一对象上调用 notify() 方法来唤醒它。所以这些线程要有共同的对象，这样才能与其他的线程完成通信。下面以 <code>生产者-消费者</code> 的例子来演示</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e"> *  产品类
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Condom</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// true 产品还有，没卖完
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> isStatus <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>

<span style="color:#75715e">/**
</span><span style="color:#75715e"> *  生产者类
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Producer</span> <span style="color:#66d9ef">extends</span> Thread <span style="color:#f92672">{</span>
    <span style="color:#75715e">// 内部接收产品对象
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> Condom condom<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Producer</span><span style="color:#f92672">(</span>Condom condom<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">condom</span> <span style="color:#f92672">=</span> condom<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// 将接收到的对象作为锁对象
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">synchronized</span> <span style="color:#f92672">(</span>condom<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>condom<span style="color:#f92672">.</span><span style="color:#a6e22e">isStatus</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                <span style="color:#75715e">// 商品还有，生产者等待
</span><span style="color:#75715e"></span>                System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;货还有，快点买，我等你&#34;</span><span style="color:#f92672">);</span>
                <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
                    condom<span style="color:#f92672">.</span><span style="color:#a6e22e">wait</span><span style="color:#f92672">();</span>
                <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>InterruptedException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                    e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
                <span style="color:#f92672">}</span>
            <span style="color:#f92672">}</span>
            <span style="color:#75715e">// 若商品没了，上满货，通知消费者购买
</span><span style="color:#75715e"></span>            condom<span style="color:#f92672">.</span><span style="color:#a6e22e">isStatus</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;快点买货，通知你了&#34;</span><span style="color:#f92672">);</span>
            condom<span style="color:#f92672">.</span><span style="color:#a6e22e">notify</span><span style="color:#f92672">();</span>    
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

<span style="color:#75715e">/**
</span><span style="color:#75715e"> *  消费者类
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Customer</span> <span style="color:#66d9ef">extends</span> Thread <span style="color:#f92672">{</span>
    <span style="color:#75715e">// 内部接收产品对象
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> Condom condom<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Customer</span><span style="color:#f92672">(</span>Condom condom<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">condom</span> <span style="color:#f92672">=</span> condom<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// 将接收到的对象作为锁对象
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">synchronized</span> <span style="color:#f92672">(</span>condom<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// 商品没了，消费者等待
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>condom<span style="color:#f92672">.</span><span style="color:#a6e22e">isStatus</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;货卖完了，快点生产，我等你&#34;</span><span style="color:#f92672">);</span>
                <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
                    condom<span style="color:#f92672">.</span><span style="color:#a6e22e">wait</span><span style="color:#f92672">();</span>
                <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>InterruptedException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                    e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
                <span style="color:#f92672">}</span>
            <span style="color:#f92672">}</span>
            <span style="color:#75715e">// 若商品还有，买完货，通知生产者生产
</span><span style="color:#75715e"></span>            condom<span style="color:#f92672">.</span><span style="color:#a6e22e">isStatus</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;快点上货，通知你了&#34;</span><span style="color:#f92672">);</span>
            condom<span style="color:#f92672">.</span><span style="color:#a6e22e">notify</span><span style="color:#f92672">();</span>    
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

<span style="color:#75715e">/**
</span><span style="color:#75715e"> *  测试类
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Test</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// 新建一个商品对象
</span><span style="color:#75715e"></span>    Condom condom <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Condom<span style="color:#f92672">();</span>
    <span style="color:#75715e">// 让两线程共同调用该商品
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> Producer<span style="color:#f92672">(</span>condom<span style="color:#f92672">),</span> <span style="color:#e6db74">&#34;厂家&#34;</span><span style="color:#f92672">).</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
    <span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> Customer<span style="color:#f92672">(</span>condom<span style="color:#f92672">),</span> <span style="color:#e6db74">&#34;买家&#34;</span><span style="color:#f92672">).</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
<span style="color:#f92672">}</span></code></pre></div>
<p><img src="https://cdn.jsdelivr.net/gh/junq0420/blog_image/producer_customer.jpg" alt="Producer_Customer" /></p>

  

  

</article> 



        </div> <!-- /.blog-main -->

        <aside class="col-sm-3 ml-auto blog-sidebar">
  
  <section class="sidebar-module sidebar-module-inset">
    <h4>About</h4>
    <p dir="auto">欢迎访问我的博客，这是我的 <a href="https://github.com/junq0420">Github</a></p>
  </section>
  

  
        <section class="sidebar-module">
    <h4>Recent Posts</h4>
    <ol class="list-unstyled">


<li><a href="/2022/04/collection2/">Collection2</a></li>

<li><a href="/2022/03/develop_standard/">Develop_Standard</a></li>

<li><a href="/2022/03/advance/">Advance</a></li>

<li><a href="/2022/03/querystatement/">QueryStatement</a></li>

<li><a href="/2022/03/primary_key/">Primary_key</a></li>

    </ol>
  </section>

  

  
  <section class="sidebar-module">
    <h4>Links</h4>
    <ol class="list-unstyled">
      
      <li><a href="https://www.bilibili.com/">Bilibili</a></li>
      
      <li><a href="https://www.google.com">Google</a></li>
      
    </ol>
  </section>
  
</aside>


      </div> <!-- /.row -->
    </div> <!-- /.container -->
    

    
    <footer class="blog-footer">
      <p dir="auto">
      
      除非特别声明, 本站采用技术 <a href="https://gohugo.io/">Hugo</a> &amp; 主题 <a href="https://themes.gohugo.io/themes/hugo-theme-bootstrap4-blog/">hugo-theme-bootstrap4-blog</a>.
      
      </p>
      <p>
      <a href="#">Back to top</a>
      </p>
    </footer>
    

  </body>

</html>
